#!/usr/bin/env python3
"""
Computes the percent of `raise ...` statements in `src/` that were executed.

This is intended as a lightweight, repeatable proxy for "error messages produced"
using the same coverage data generated by the integration/E2E coverage run.
"""

from __future__ import annotations

import argparse
import ast
import os
from pathlib import Path

import coverage


def _iter_python_files(root: Path) -> list[Path]:
    return sorted(
        p
        for p in root.rglob("*.py")
        if p.is_file() and not any(part.startswith(".") for part in p.parts)
    )


def _raise_lines(path: Path) -> set[int]:
    try:
        source = path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        source = path.read_text(encoding="utf-8", errors="replace")

    try:
        tree = ast.parse(source, filename=str(path))
    except SyntaxError:
        return set()

    return {node.lineno for node in ast.walk(tree) if isinstance(node, ast.Raise)}


def _pick_measured_path(measured_files: set[str], abs_path: str) -> str | None:
    if abs_path in measured_files:
        return abs_path
    real_path = os.path.realpath(abs_path)
    if real_path in measured_files:
        return real_path
    return None


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--data-file",
        default=".coverage.integration",
        help="Coverage data file to read (default: .coverage.integration).",
    )
    parser.add_argument(
        "--fail-under",
        type=float,
        default=80.0,
        help="Exit non-zero if percent covered is below this threshold.",
    )
    args = parser.parse_args()

    src_root = Path("src")
    cov = coverage.Coverage(data_file=args.data_file)
    cov.load()
    data = cov.get_data()
    measured_files = set(data.measured_files())

    total_raise_lines = 0
    covered_raise_lines = 0

    for py_file in _iter_python_files(src_root):
        abs_path = str(py_file.resolve())
        measured_path = _pick_measured_path(measured_files, abs_path)
        if measured_path is None:
            continue

        executed = set(data.lines(measured_path) or [])
        raises = _raise_lines(py_file)
        if not raises:
            continue

        total_raise_lines += len(raises)
        covered_raise_lines += len(raises & executed)

    percent = 100.0 if total_raise_lines == 0 else (covered_raise_lines / total_raise_lines) * 100.0
    print(
        f"raise-statements covered: {covered_raise_lines}/{total_raise_lines} "
        f"({percent:.2f}%)  data_file={args.data_file}"
    )

    return 0 if percent >= args.fail_under else 2


if __name__ == "__main__":
    raise SystemExit(main())
